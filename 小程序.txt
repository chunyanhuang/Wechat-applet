
微信小程序：
   实现功能：类似于 首页， 分类， 搜索， 购物车， 商品支付
   技术： wepy + vant weapp 
     wepy: 小程序快速开发框架，语法类似vue
     vant-weapp： 小程序的ui组件库


wepy build --watch：编译后将src文件生成为dist文件，最终小程序展示的是dist文件中内容

wepy框架：1.6版本
  .wpy文件编译生成 .wxml .wxss .js .json 

vant-weapp： 
   作为组件引入项目，在微信开发中，引入全局组件，要在app.json的usingcomponent中引入



功能实现步骤：

存储到本地有： 历史搜索数据kw, 收货地址address, 购物车数据cart
token??

  1. 初始化项目：
       wepy init standard ugo
       cd ugo
       npm install
       wepy build --watch
       在微信开发工具中查看效果
  2.绘制tabBar
      在app.wpy中添加pages相应路径和tabBar节点(全局配置)
      修改window节点中的导航栏样式
  3.首页
     1. 默认wepy-cli创建的项目不支持es7的async和await来简化primise的调用，需要手动设置，在app.wpy的promise的constructor中this.use('promisify')，开启async和await(属于wepy框架封装好的)
     2. 抽离页面的js代码， 利用wepy的mixin混合语法，其中@代表src这个路径
     3.发送请求获取轮播图数据
        swiper, navigator属于小程序开发文档
        注意： 在异步函数中更新数据的时，必须手动调用this.$apply方法同步页面
        rpx属于微信小程序开发文档的响应式单位
     4. 获取首页分类数据, 楼层相关数据
         优化Ui结构
         注册事件函数，点击楼层图片跳转到相应的商品列表，编程式导航
         消息提示框ShowToast() 属于微信开发文档API内容
         封装请求方法到全局文件baseAPI.js 
  4.分类
      1. 发送请求获取所有的分类数据 cateList
      2. 下载vant-weapp， 将lib改为vant, 复制到src -> assets 中 
      3. 引入vant组件，渲染左侧的一级分类列表
         scroll-view（可滚动视图区域）属于微信组件
         获取屏幕高度：wx.getSystemInfo() (微信API) 定义为当前视图的可滚动的区域
         切换一级分类时根据一级分类的索引，获取相应的二级分类
      4.渲染右侧二级和三级分类
        点击三级分类跳转到相应的商品分类列表，编程式导航
  5. 拦截器
    使用wepy的全局拦截器，在app.wpy的constructor中，在config()中请求发出时显示loading效果，wx.showLoading()属于微信API; 在请求完成时complete中调用hideLoading()方法
  6. 搜索页面
      先在usingComponents中注册全局组件
      1. x渲染搜索框，监听bind:change事件
         当搜索内容发生变化(onchange)就发送请求获取搜索内容的数据，并渲染到搜索框的下面
         1.搜索列表
            当点击搜索列表中的每一项跳转到相应的商品详情, goods_detail,并携带着商品的id
         2. 若搜索框内容为空或只有空格时，重置搜索列表数据
      2. 点击搜索框回车触发 bind:search事件
         将搜索框内容存放到历史记录，wx.setStorageSync() 微信的API;
         然后跳转到商品列表 goods_list
      3. 页面加载期间 onLoad() 读取历史搜索关键词列表
      4. 定义计算属性来决定是否展示历史搜索
          当输入框内容为空时展示历史搜索
          不为空时展示搜索数据
      5.当点击历史搜索的垃圾箱按钮时，清空历史搜索数据，并清空setStroage中的数据
  7. 回车搜索框时，进入商品列表goods_list
      1. 首先根据查询参数发送请求获取商品数据
          data中定义相关数据，onLoad()中获取数据
          美化样式
      2. 实现上拉加载更多
          1.上拉触底函数：onReachBottom() ，触发了就将页码pagenum++, 重新获取商品数据 ，
          2.如果数据加载完，就在页面底部显示完结信息，并直接return，不再发送请求获取数据
          3.解决如果上拉刷新时请求还未执行完，又重新触发了上拉刷新的问题
            定义一个变量isLoading, 默认为false, 开始请求时设为true，请求完成时设为false, 那么在onReachBottom()中设置判断isLoading, 若为true，就直接return, 不发送请求
          4. 将后续下拉刷新的数据与前面的数据进行合并，使用扩展运算符
        总结：实现过程
          每次上拉触底获取新数据，并将获取的新数据与之前的数据进行合并展示；同时判断数据是否加载完(通过比较页数和每页数据乘积与总数据的大小)，加载完就直接return，不再发送请求获取数据；同时数据加载完就显示到底的边框
          注意：防止重复发起数据请求
                使用变量，当开始发送请求时置为true,请求完成时置为false;若变量为true，则不能触发请求(节流)
      3. 下拉刷新onPullDownRefresh()
          相当于初始化，只获取第一页数据，发送请求时通过回调函数，停止下拉刷新效果
      4.点击商品列表item，跳转到商品详情页 goods_detail (携带着商品Id) ，通过编程式导航
  8. 商品详情页 goods_detail (两种方式可以跳转到整个页面)
      1. onLoad(options)中的options可接受传递过来的参数，根据传递过来的商品id, 发送请求获取商品信息，并将商品信息存储起来
      2.根据请求回来的商品信息绘制轮播图UI结构，并美化样式
      3.绘制 价格title运费 区域的ui结构
      4.绘制 促销已选区域的UI结构
      5.绘制收货地址区域 
          注册点击事件，选择收货地址；调用微信的开发接口wepy.chooseAddress()，将地址存储起来，并存放到本地setStorageSync()
      6.使用van-tabs绘制图文详情和规格参数tab栏
          先循环渲染规格参数的数据
          绘制图文详情：引入微信插件wxparse, 渲染图文详情
      7.为轮播图实现点击时预览的处理
          调用微信API: wx.previewImage() 实现在新页面全屏预览图片
      8.通过计算属性动态渲染收货地址
          若地址数据为空，就return '请选择收货地址'
          若地址不为空， 就返回地址信息的拼接结果
      9. 渲染底边固定栏：购物车+加入购物车+立即购买
          1. 通过open-type的contact开启客服功能
  9.加入购物车 
      1. 点击加入购物车，注册函数，使用showToast显示加入购物车成功
      2. 在app.wpy中通过globalData定义全局的购物车列表cart
         与globalData平级自定义的函数，可在全局通过this.$parent访问到
      3. 点击加入购物车时，调用全局的添加商品到购物车的方法，并将当前商品的信息传递过去，然后将商品信息存入购物车列表数组
      4.优化商品对象，将需要的商品信息进行梳理，再存入购物车列表数组
      5. 防止商品重复添加
          根据findIndex()判断当前购物车列表是否有要存入的商品，若有只将对应商品的count++，否则就将商品重新存入数组
      6. 利用setStorageSync()持久化的将购物车列表数据存入本地
         在小程序启动后onLoad()，就将本地的购物车列表数据赋给相应的数据
      7.点击购物车图标进入购物车tab页面cart
  10. 购物车页面cart
      1. onLoad() 将全局的购物车数据加载到当前页面的cart, 然后判断购物车的数据长度，若小于或等于0，就显示空购物车UI结构；否则，就显示非空购物车的UI结构 
      2. 循环渲染商品列表区域
         1.当修改商品数量时，获取商品的数量和id,然后调用全局的更新数量方法，并将这两个参数传递过去，修改对应id的商品的数量
      3.通过插槽渲染复选框和缩略图
         当复选框状态发生变化时，触发函数，获取当前的状态和商品id,调用全局的状态更新函数，修改对应id的商品的状态
          商品的任何信息修改后都应重新存储到本地
      4. 右滑删除商品
          注册tap事件，并将商品id传递过去，调用全局的删除商品函数，通过splice删除对应商品
      5. 渲染提交订单区域UI结构
          1. 通过计算属性计算所有勾选了的商品的总价钱
          2. 通过计算属性判断全选状态，利用every()方法，有一个未选中，则全选为false, 所有均选中，则全选未true,
          3.点击全选按钮时，获取全选按钮的状态，调用全局的更新所有复选框状态的方法
      6.为购物车tab添加数字角标
          1.全局定义渲染角标的函数，调用微信API: wx.setTabBarBadge() 
          2.并在onLoad()中调用，使得页面一加载就显示；数据重新保存到本地也要调用
          3.在商品详情页面添加数字角标
            通过info属性引用全局的total显示总数
          4.点击提交订单，跳转到确认订单页面 order 
  11.确认订单页面 
      1. 渲染添加地址的按钮
          点击按钮触发函数，调用wepy.chooseAddress()，选择收货地址，并存储到本地；然后页面一加载就读取内存中收货地址
      2. 通过计算属性控制收货地址按钮和收货人信息区域的按需显示； 有地址显示地址，没有地址显示按钮
      3. 渲染收货人，联系电话和收货地址 ，并美化
           收货地址通过计算属性显示
           点击联系电话，调用chooseAddress()方法，可以重新选择收货地址
      4. onLoad()中获取所有被选中的商品，存入cart
      5. 渲染登录后下单按钮      
  12. 订单支付 pages/order
      1. 准备登录相关参数（！重要！）
          1. 为登录按钮设置open-type, bindgetuserinfo属性，来获取当前用户的信息
          2.用户信息获取成功，就调用wepy.login()，返回结果中的code，就表示登录的凭证
          3.根据用户信息中的相关参数和登录凭证，发起登录请求
          4.登录成功将返回结果中的token存储到本地
          5.按需渲染登录按钮和订单支付区域，若登录成功就显示订单支付
          6.在app.wpy中通过拦截器为请求头添加authorization字段，存储token
      2. 登录成功后显示订单支付栏(共发起3次数据请求)(！重要！)
          1. 利用计算属性，计算订单总价格
          2. 点击支付订单，发起支付请求
              1. 首先判断订单总金额不能为空，地址不能为空
              2.发起post请求创建订单
                  创建订单成功就保存订单信息orderInfo
              3.发起post请求创建预支付订单
                  根据前一步的订单信息中的订单编号，发起请求生成预支付订单
              4.订单生成成功就发起支付
                  根据预支付订单的信息，利用微信API, wepy.requestPayment()发起支付 
              5.检查支付结果
                  发起请求根据订单编号，查询支付结果
                  支付成功就显示提示信息，并跳转到订单列表页面orderlist
  13. 订单列表 orderlist (包括全部，已付款，未付款的数据)
       1. 渲染tab标签页，渲染订单列表的全部，已付款，未付款； 
       2.当切换tab时，更改当前的激活项为当前的点击项；然后发起请求，获取当前tab栏的订单信息；同时在onLoad()即页面一渲染就发起请求获取当前tab栏的订单信息
       3. 获取订单列表，请求参数： 1：全部；2：待付款；3：已付款
          请求成功将返回结果的order_detail转换成对象；然后根据不同tab，将结果分别赋给data中的对应数组
       4. 渲染订单列表UI结构 
           分离出组件，学习wepy中的自定义组件使用
           wepy的自定义组件：
                repeat辅助标签，实现循环组件
                组件通过props接收数据，页面通过属性传递数据

 

重点功能：
    1.获取用户信息进行登录，登录成功就将信息存储在本地token
    2.支付流程 : 金额和收货地址不能为空 -> 创建订单 -> 生成预支付订单 -> 走支付流程，调用微信支付的API: wepy.requestPayment -> 检查用户支付的结果 -> 提示用户支付成功,再跳转到订单列表页面    
    3. getStorageSync/setStorageSync   存储：历史搜索kw, address收货地址，cart购物车商品列表，token登录信息
    4. 通过拦截器为请求头添加authorization字段，存储token；并且为所有请求添加loading效果
    5. 商品列表上拉刷新，下拉加载更多
    6. 商品展示轮播图：首页和商品详情页中利用微信开发文档的swiper组件实现
    7. 封装wepy.request请求数据
    8. 购物车列表商品的增删，价格的计算
    9. 购物车添加商品

数组角标是商品样数，不是所有商品件数


block
wx:for wx:key
wepy.chooseAddress()
constructor
wepy.login()
wepy.chooseAddress()
微信的开发接口都是异步的？
wepy的1.x和2.x的区别

项目优化方面
代码重构和升级，保证代码的长期稳定性
熟练掌握小程序api,熟悉开发测试打包发布流程
web服务端开发(nodejs)及web系统安全
前端工程化，模块化，工程化